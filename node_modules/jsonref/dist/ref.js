"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolve = void 0;
const meta = __importStar(require("./meta"));
const pointer = __importStar(require("./pointer"));
const RELATIVE_RE = /^#(?:0|[1-9][0-9]*?)(?:$|\/)/;
function deref(obj) {
    let out;
    if (obj.$ref.match(RELATIVE_RE)) {
        out = pointer.resolve(obj, obj.$ref.substr(1));
    }
    else {
        const scope = meta.getMeta(obj).scope;
        const uri = new URL(obj.$ref, scope);
        const path = uri.hash ? uri.hash.substr(1) : undefined;
        uri.hash = '';
        out = meta.getMeta(obj).registry[uri.toString() + '#'];
        if (!out) {
            throw new Error(`Reference not in registry (${uri.toString()})`);
        }
        else if (path) {
            out = pointer.resolve(out, path);
        }
    }
    return out;
}
function resolve(obj, options) {
    if (obj === null || typeof obj !== 'object') {
        return obj;
    }
    return (function _parse(obj) {
        if (!meta.isAnnotated(obj)) {
            obj = meta.annotate(obj, options);
        }
        if (meta.isDerefd(obj)) {
            return obj;
        }
        else if (meta.isRef(obj)) {
            return deref(obj);
        }
        else {
            const orig = Object.assign({}, obj);
            Object.defineProperty(obj, 'toJSON', {
                get: () => () => orig,
                enumerable: false,
                configurable: false,
            });
            const keys = Object.keys(obj);
            for (let key of keys) {
                const next = obj[key];
                if (next !== null && typeof next === 'object') {
                    if (meta.isRef(next)) {
                        Object.defineProperty(obj, key, {
                            get: () => {
                                Object.defineProperty(obj, key, {
                                    value: deref(next),
                                    enumerable: true,
                                    configurable: true,
                                    writable: true,
                                });
                                return obj[key];
                            },
                            enumerable: true,
                            configurable: true,
                        });
                    }
                    else {
                        obj[key] = _parse(next);
                    }
                }
                else {
                    obj[key] = next;
                }
            }
            meta.getMeta(obj).derefd = true;
            return obj;
        }
    })(obj);
}
exports.resolve = resolve;
//# sourceMappingURL=ref.js.map